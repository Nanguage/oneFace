{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>oneFace is a Python library for automatically generating multiple interfaces(CLI, GUI, WebGUI) from a callable Python object.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Generate CLI, Qt GUI, Dash Web app from a python function or a command line.</li> <li>Automatically check the type and range of input parameters and pretty print them.</li> <li>Easy extension of parameter types and GUI widgets.</li> <li>Support for embedding the generated interface into a parent application.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To install oneFace with complete dependency:</p> <pre><code>$ pip install \"oneface[all]\"\n</code></pre> <p>Or install with just qt or dash dependency:</p> <pre><code>$ pip install \"oneface[qt]\"  # qt\n$ pip install \"oneface[dash]\"  # dash\n</code></pre>"},{"location":"#qt-bindings","title":"Qt bindings","text":"<p>oneFace support different Qt bindings: PyQt6(default), PyQt5, PySide2, PySide6. It can be specified: </p> <pre><code>$ pip install \"oneface[pyside2]\"  # for example\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>oneFace is an easy way to create interfaces in Python, just decorate your function and mark the type and range of the arguments:</p> <pre><code>from oneface import one, Val\n@one\ndef bmi(name: str,\nheight: Val[float, [100, 250]] = 160,\nweight: Val[float, [0, 300]] = 50.0):\nBMI = weight / (height / 100) ** 2\nprint(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn BMI\n# run cli\nbmi.cli()\n# or run qt_gui\nbmi.qt_gui()\n# or run dash web app\nbmi.dash_app()\n</code></pre> <p>These code will generate the following interfaces:</p> CLI Qt Dash"},{"location":"basic_usage/","title":"Basic Usage","text":"<p>Using <code>one</code> decorate the function, and use <code>Val</code> mark type and range of the arguments.</p> <pre><code>from oneface import one, Val\n@one\ndef print_person(name: str, age: Val[int, [0, 120]]):\nprint(f\"{name} is {age} years old.\")\n</code></pre> <p>Note: <code>Val(type, range)</code> is same to <code>Val[type, range]</code>.</p> <pre><code># This is same to the previous defination\n@one\ndef print_person(name: str, age: Val(int, [0, 120])):\nprint(f\"{name} is {age} years old.\")\n</code></pre> <p>You can also mark arguments using decorators in <code>funcdesc</code>:</p> <pre><code>from oneface import one\nfrom funcdesc import mark_input\n@one\n@mark_input(\"age\", range=[0, 120])\ndef print_person(name: str, age: int):\nprint(f\"{name} is {age} years old.\")\n</code></pre> <p>This code achieves the same effect as the previous example, and you can refer to the <code>funcdesc</code> for more information about the <code>mark_input</code> decorator.</p>"},{"location":"basic_usage/#type-and-range-checking","title":"Type and range checking","text":"<p>Functions decorated with <code>one</code> will automatically check the type and range of input parameters:</p> <pre><code>&gt;&gt;&gt; print_person(\"Tom\", 20)\nRun: print_person\nArguments table:\nArgument  Type           Range     InputVal  InputType\nname      &lt;class 'str'&gt;  None      Tom       &lt;class 'str'&gt;\nage       &lt;class 'int'&gt;  [0, 120]  20        &lt;class 'int'&gt;\nTom is 20 years old.\n</code></pre> <p>If we pass parameters with incorrect type or range, it will raise an exception:</p> <pre><code>&gt;&gt;&gt; print_person(100, -20)  # incorrect input type and range\nRun: print_person\nArguments table:\nArgument  Type           Range     InputVal  InputType\nname      &lt;class 'str'&gt;  None      100       &lt;class 'int'&gt;\nage       &lt;class 'int'&gt;  [0, 120]  -20       &lt;class 'int'&gt;\nTraceback (most recent call last):\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\tmp\\test1.py\", line 9, in &lt;module&gt;\nprint_person(100, -20)\nFile \"C:\\Users\\Nangu\\miniconda3\\envs\\oneface\\lib\\site-packages\\funcdesc\\guard.py\", line 46, in __call__\nself.check_inputs(pass_in, errors)\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\oneface\\check.py\", line 86, in check_inputs\nraise CheckError(errors)\nfuncdesc.guard.CheckError: [TypeError(\"Value 100 is not in valid type(&lt;class 'str'&gt;)\"), ValueError('Value -20 is not in a valid range([0, 120]).')]\n</code></pre>"},{"location":"basic_usage/#turn-off-arguments-print","title":"Turn-off arguments print","text":"<p>By default, oneface will pretty print the input arguments with a table. It can be turned off with the <code>print_args</code> parameter:</p> <pre><code>@one(print_args=False)\ndef print_person(name: str, age: Val[int, [0, 120]]):\nprint(f\"{name} is {age} years old.\")\n&gt;&gt;&gt; print_person(\"Tom\", 20)\nTom is 20 years old.\n</code></pre>"},{"location":"basic_usage/#create-interfaces","title":"Create interfaces","text":"<p>Create a python module <code>print_person.py</code>:</p> <pre><code>from oneface import one, Arg\n@one\ndef print_person(name: str, age: Arg[int, [0, 120]]):\nprint(f\"{name} is {age} years old.\")\nprint_person.cli()\n</code></pre> <p>This will create a Command Line Interface for <code>print_person</code> function. You can call this function in the Shell:</p> <pre><code>$ python print_person.py Tom 20\nRun: print_person\nArguments table:\n\nArgument  Type           Range     InputVal  InputType\n name      &lt;class 'str'&gt;  None      Tom       &lt;class 'str'&gt;\n age       &lt;class 'int'&gt;  [0, 120]  20        &lt;class 'int'&gt;\n\nTom is 20 years old.\n</code></pre> <p>If you want change to another interface, just change the <code>.cli()</code> to <code>.qt_gui()</code> or <code>.dash_app()</code>. Then run this file again:</p> <pre><code>$ python print_person.py\n</code></pre> <p>You will got the Qt gui:</p> <p></p> <p>Or Dash web app: </p>"},{"location":"builtin_types/","title":"Built-in argument types","text":"<p>oneFace support the following types:</p> Type Example Type check Range check Description str <code>Val(str)</code> <code>True</code> <code>False</code> String input. int <code>Val(int, [0, 10])</code> <code>True</code> <code>True</code> Int input. float <code>Val(float, [0, 1])</code> <code>True</code> <code>True</code> Float input. bool <code>Val(bool)</code> <code>True</code> <code>False</code> Bool input. OneOf <code>Val(OneOf, [\"a\", \"b\", \"c\"])</code> <code>False</code> <code>True</code> Input should be a element of the range. SubSet <code>Val(SubSet, [\"a\", \"b\", \"c\"])</code> <code>False</code> <code>True</code> Input should be a subset of the range. InputPath <code>Val(InputPath)</code> <code>True</code> <code>True</code> Input should be an exist file path(<code>str</code> or <code>pathlib.Path</code>). OutPath <code>Val(OutputPath)</code> <code>True</code> <code>False</code> Input should be a file path(<code>str</code> or <code>pathlib.Path</code>) <p>This example show all built-in types, name as <code>builtin_example.py</code>:</p> <pre><code>from oneface.core import one, Val\nfrom funcdesc.types import (OneOf, SubSet, InputPath, OutputPath)\n@one\ndef func(in_path: InputPath,\nout_path: OutputPath = \"./test\",\na: Val[int, [0, 10], text=\"parameter (a)\"] = 10,\nb: Val[float, [0, 1]] = 0.1,\nc: Val[str] = \"aaaa\",\nd: Val[bool] = False,\ne: Val[OneOf, [\"a\", \"b\", \"c\"]] = \"a\",\nf: Val[SubSet, [\"a\", \"b\", \"c\"]] = [\"a\"]):\nprint(in_path, out_path)\nprint(a, b, c, d, e, f)\nreturn a + b\nfunc.qt_gui()\n</code></pre> <p>Running the script will get:</p> <p></p> <p>Change the last line to <code>func.dash_app()</code> and run it again, you will get:</p> <p></p>"},{"location":"dash_confs/","title":"Dash interface configs","text":""},{"location":"dash_confs/#hidden-console","title":"Hidden console","text":"<p>oneface dash provides a terminal for displaying operational status. The <code>show_console</code> parameter is used to control whether it is displayed.</p> <pre><code>from oneface import one, Val\n@one\ndef bmi(name: str = \"Tom\",\nheight: Val[float, [100, 250]] = 160,\nweight: Val[float, [0, 300]] = 50.0):\nBMI = weight / (height / 100) ** 2\nprint(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn BMI\nbmi.dash_app(show_console=False)\n</code></pre> <p>Will not show the console.</p>"},{"location":"dash_confs/#console-refresh-interval","title":"Console refresh interval","text":"<p>By default, the console is refreshed in 2 seconds (2000 microseconds). <code>console_interval</code> can be used to set the refresh interval</p> <pre><code>bmi.dash_app(console_interval=1000)\n</code></pre> <p>Will set refresh interval to 1 second.</p>"},{"location":"dash_confs/#argument-label","title":"Argument label","text":"<p>By default, argument label is the variable name. But it can be explicitly set by <code>text</code> parameter:</p> <pre><code>@one\ndef bmi(name: Val(str, text=\"NAME\"),  # explicitly label setting\nheight: Val(float, [100, 250]) = 160,\nweight: Val(float, [0, 300]) = 50.0):\nBMI = weight / (height / 100) ** 2\nprint(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn BMI\n</code></pre>"},{"location":"dash_confs/#init-run","title":"Init run","text":"<p>By default, it is not called until the user clicks the run button. However, the initial call can be turned on by setting <code>init_run=True</code>:</p> <pre><code>bmi.dash_app(init_run=True)\n</code></pre> <p>This will cause the <code>bmi</code> function to be called once automatically at the end of app initialization. In this case, all parameters need to have default values.</p>"},{"location":"dash_confs/#interactive-parameter","title":"Interactive parameter","text":"<p>Interactive parameters rerun the function each time the input is changed. We can use <code>Val</code>'s parameter to mark the interactive mode, for example we mark <code>height</code> as interactive:</p> <pre><code>@one\ndef bmi(name: Val(str) = \"Tom\",\nheight: Val(float, [100, 250], interactive=True) = 160,\nweight: Val(float, [0, 300]) = 50.0):\nBMI = weight / (height / 100) ** 2\nprint(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn BMI\n</code></pre> <p></p> <p>And, if you pass <code>interactive = True</code> to the <code>.dash_app</code> method, it will mark all parameters as interactive:</p> <pre><code>bmi.dash_app(interactive=True)\n</code></pre>"},{"location":"dash_confs/#result-show-type","title":"Result show type","text":"<p>By default, the <code>result_show_type</code> is <code>'text'</code>, which means that the result will be displayed in text. In addition, the results can also be presented in other forms:</p>"},{"location":"dash_confs/#plotly-figure-type","title":"Plotly figure type","text":"<p>Dash app can integrate the plotly to drawing dynamic figures in HTML. By setting <code>result_show_type</code> to <code>'plotly'</code> and wrap a function return the plotly figure object, we can archieve this:</p> <pre><code>from oneface import one, Val\nimport plotly.express as px\nimport numpy as np\n@one\ndef draw_random_points(n: Val[int, [1, 10000]] = 100):\nx, y = np.random.random(n), np.random.random(n)\nfig = px.scatter(x=x, y=y)\nreturn fig\ndraw_random_points.dash_app(\nresult_show_type='plotly',\ndebug=True)\n</code></pre> <p></p>"},{"location":"dash_confs/#download-type","title":"Download type","text":"<p>In many cases, the results of running a web application need to be downloaded as a file for the user. You can set the <code>result_show_type='download'</code> for this purpose. In this case, the target function should return the path to the result file:</p> <pre><code>from oneface import one, Val\n@one\ndef bmi(name: Val(str) = \"Tom\",\nheight: Val(float, [100, 250], interactive=True) = 160,\nweight: Val(float, [0, 300]) = 50.0):\nBMI = weight / (height / 100) ** 2\nout_path = f\"./{name}_bmi.txt\"\nwith open(out_path, 'w') as fo:\nfo.write(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn out_path\nbmi.dash_app(result_show_type=\"download\")\n</code></pre> <p></p>"},{"location":"dash_confs/#custom-result-type","title":"Custom result type","text":"<p>You can custom the dash app layout by inherit the <code>oneface.dash_app.App</code> class. For example we can create a app draw a random series:</p> <pre><code># random_series.py\nfrom oneface.dash_app import App\nfrom oneface import Val, one\nimport numpy as np\nimport plotly.express as px\nfrom dash import Dash, Output, Input, dcc\nclass PlotSeries(App):\ndef __init__(self, func, **kwargs):\nsuper().__init__(func, **kwargs)\ndef get_result_layout(self):\n# override the result layout definition\nlayout = self.base_result_layout()\nlayout += [\ndcc.Graph(id='line-plot')\n]\nreturn layout\ndef add_result_callbacks(self, app: \"Dash\"):\n# override the result callback definition\n@app.callback(\nOutput(\"line-plot\", \"figure\"),\nInput(\"out\", \"data\"),\n)\ndef plot(val):\nfig = px.line(val)\nreturn fig\n@one\ndef random_series(n: Val[int, [0, 10000]] = 100):\nreturn np.random.random(n) * 100\np = PlotSeries(random_series, debug=True)\np()\n</code></pre> <p>Run this script, we get:</p> <p></p>"},{"location":"dash_confs/#host-and-port","title":"Host and Port","text":"<p>Specify the app's host and port:</p> <pre><code>bmi.dash_app(host=\"0.0.0.0\", port=9000)\n</code></pre>"},{"location":"dash_confs/#debug-mode","title":"debug mode","text":"<p>The debug mode is useful for debugging errors, use <code>debug=True</code> to open it:</p> <pre><code>bmi.dash_app(debug=True)\n</code></pre>"},{"location":"dash_embed/","title":"Embeding dash to Flask web app","text":"<p>You can embed the oneFace generated dash app in a Flask application to integrate a number of dash apps when needed, or to leverage the power of Flask for additional functionality.</p> <p>Here is an example where we have integrated the <code>add</code> and <code>mul</code> applications into a single Flask server:</p> <pre><code># demo_flask_integrate.py\nfrom flask import Flask, url_for\nfrom oneface.dash_app import flask_route\nfrom oneface.core import one\nfrom oneface.dash_app import app\nserver = Flask(\"test_dash_app\")\n@flask_route(server, \"/add\")\n@one\ndef add(a: int, b: int) -&gt; int:\nreturn a + b\n@flask_route(server, \"/mul\")\n@app(console_interval=500)\n@one\ndef mul(a: int, b: int) -&gt; int:\nreturn a * b\n@server.route(\"/\")\ndef index():\nreturn f\"\"\"\n    &lt;h1&gt;Hello&lt;/h1&gt;\n    &lt;div&gt;\n        &lt;p&gt;You can run the following applications:&lt;/p&gt;\n        &lt;div&gt;\n        &lt;ul&gt;\n            &lt;li&gt;&lt;a href=\"{url_for(\"add\")}\"&gt;add&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"{url_for(\"mul\")}\"&gt;mul&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    \"\"\"\nserver.run(\"127.0.0.1\", 8088)\n</code></pre> <p></p>"},{"location":"qt_confs/","title":"Qt interface configs","text":""},{"location":"qt_confs/#window-name","title":"Window name","text":"<p>By default the window name is the name of the function, but it can be changed by <code>name</code> parameter of <code>.qt_gui</code> method:</p> <pre><code>from oneface import one, Val\n@one\ndef bmi(name: str,\nheight: Val[float, [100, 250]] = 160,\nweight: Val[float, [0, 300]] = 50.0):\nBMI = weight / (height / 100) ** 2\nprint(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn BMI\nbmi.qt_gui(name=\"BMI calculator\")\n</code></pre> <p></p>"},{"location":"qt_confs/#argument-label","title":"Argument label","text":"<p>By default, argument label is the variable name. But it can be explicitly set by <code>text</code> parameter:</p> <p><pre><code>@one\ndef bmi(name: Val(str, text=\"NAME\"),  # explicitly label setting\nheight: Val[float, [100, 250]] = 160,\nweight: Val[float, [0, 300]] = 50.0):\nBMI = weight / (height / 100) ** 2\nprint(f\"Hi {name}. Your BMI is: {BMI}\")\nreturn BMI\n</code></pre> </p>"},{"location":"qt_confs/#run-multiple-times","title":"Run multiple times","text":"<p>By default, oneface Qt interface run only once then exit, when click the run button.</p> <p></p> <p>You can use the <code>run_once=False</code> to make it run multiple times:</p> <pre><code>bmi.qt_gui(run_once=False)\n</code></pre> <p></p>"},{"location":"qt_confs/#window-size","title":"Window size","text":"<p>The <code>size</code> parameter is used to explicitly specify the window size:</p> <pre><code>bmi.qt_gui(size=(400, 600))  # width and height\n</code></pre>"},{"location":"qt_embed/","title":"Embeding generated window to a PyQt app","text":"<p>You can integrate oneFace generated Qt windows by embedding them in a Qt application:</p> <pre><code># demo_qt_embed.py\nimport sys\nfrom oneface.qt import gui\nfrom oneface import one\nfrom qtpy import QtWidgets\napp = QtWidgets.QApplication([])\n@gui\n@one\ndef add(a: int, b: int):\nres = a + b\nprint(res)\n@gui\n@one\ndef mul(a: int, b: int):\nres = a * b\nprint(res)\nmain_window = QtWidgets.QWidget()\nmain_window.setWindowTitle(\"MyApp\")\nmain_window.setFixedSize(200, 100)\nlayout = QtWidgets.QVBoxLayout(main_window)\nlayout.addWidget(QtWidgets.QLabel(\"Apps:\"))\nbtn_open_add = QtWidgets.QPushButton(\"add\")\nbtn_open_mul = QtWidgets.QPushButton(\"mul\")\nbtn_open_add.clicked.connect(add.window.show)\nbtn_open_mul.clicked.connect(mul.window.show)\nlayout.addWidget(btn_open_add)\nlayout.addWidget(btn_open_mul)\nmain_window.show()\nsys.exit(app.exec())\n</code></pre> <p>Run it:</p> <p></p>"},{"location":"type_extension/","title":"Type Extension","text":"<p>You can easily extend the argument types in oneFace.</p>"},{"location":"type_extension/#registration-of-type-and-range-check","title":"Registration of type and range check","text":"<p>For example you have a custom <code>Person</code> class:</p> <pre><code>class Person:\ndef __init__(self, name, age):\nself.name = name\nself.age = age\n</code></pre>"},{"location":"type_extension/#register-type-check","title":"Register type check","text":"<pre><code>Val.register_type_check(Person)\n</code></pre> <p>This will allow oneface to check the type of the input parameter to make sure it is an instance of <code>Person</code>:</p> <pre><code>@one\ndef print_person(person: Person):\nprint(f\"{person.name} is {person.age} years old.\")\n&gt;&gt;&gt; print_person([\"Tom\", 10])  # Incorrect input type\nRun: print_person\nArguments table:\nArgument  Type                       Range  InputVal     InputType\nperson    &lt;class '__main__.Person'&gt;  None   ['Tom', 10]  &lt;class 'list'&gt;\nTraceback (most recent call last):\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\tmp\\test1.py\", line 17, in &lt;module&gt;\nprint_person([\"Tom\", 10])\nFile \"C:\\Users\\Nangu\\miniconda3\\envs\\oneface\\lib\\site-packages\\funcdesc\\guard.py\", line 46, in __call__\nself.check_inputs(pass_in, errors)\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\oneface\\check.py\", line 86, in check_inputs\nraise CheckError(errors)\nfuncdesc.guard.CheckError: [TypeError(\"Value ['Tom', 10] is not in valid type(&lt;class '__main__.Person'&gt;)\")]\n</code></pre> <p><code>Val.register_type_check</code> also allow you to define a custom type checker, for example:</p> <pre><code>def check_person_type(val, tp):\nreturn (\nisinstance(val, tp) and\nisinstance(val.name, str) and\nisinstance(val.age, int)\n)\nArg.register_type_check(Person, check_person_type)\n</code></pre> <p>This will not only check if the input value is an instance of <code>Preson</code>, but also ensure that its attributes are of the correct type:</p> <pre><code>&gt;&gt;&gt; print_person(Person(\"Tom\", \"10\"))  # Incorrect age type\nRun: print_person\nArguments table:\nArgument  Type                       Range  InputVal                                        InputType\nperson    &lt;class '__main__.Person'&gt;  None   &lt;__main__.Person object at 0x0000021B20DD2FD0&gt;  &lt;class '__main__.Person'&gt;\nTraceback (most recent call last):\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\tmp\\test1.py\", line 24, in &lt;module&gt;\nprint_person(Person(\"Tom\", \"10\"))\nFile \"C:\\Users\\Nangu\\miniconda3\\envs\\oneface\\lib\\site-packages\\funcdesc\\guard.py\", line 46, in __call__\nself.check_inputs(pass_in, errors)\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\oneface\\check.py\", line 86, in check_inputs\nraise CheckError(errors)\nfuncdesc.guard.CheckError: [TypeError(\"Value &lt;__main__.Person object at 0x0000021B20DD2FD0&gt; is not in valid type(&lt;class '__main__.Person'&gt;)\")]\n</code></pre>"},{"location":"type_extension/#register-range-check","title":"Register range check","text":"<p>You can also register a range check for it, for example, to limit the age to a certain range:</p> <pre><code>Val.register_range_check(Person, lambda val, range: range[0] &lt;= val.age &lt;= range[1])\n</code></pre> <p>Mark the range in argument annotation:</p> <pre><code>@one\ndef print_person(person: Val[Person, [0, 100]]):\nprint(f\"{person.name} is {person.age} years old.\")\n</code></pre> <p>This will limit the person's age in the range of 0~100:</p> <pre><code>&gt;&gt;&gt; print_person(Person(\"Tom\", -10))\nRun: print_person\nArguments table:\nArgument  Type                       Range     InputVal                                      InputType\nperson    &lt;class '__main__.Person'&gt;  [0, 100]  &lt;__main__.Person object at                    &lt;class '__main__.Person'&gt;\n0x000001E9148CAD30&gt;\nTraceback (most recent call last):\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\tmp\\test1.py\", line 25, in &lt;module&gt;\nprint_person(Person(\"Tom\", -10))\nFile \"C:\\Users\\Nangu\\miniconda3\\envs\\oneface\\lib\\site-packages\\funcdesc\\guard.py\", line 46, in __call__\nself.check_inputs(pass_in, errors)\nFile \"C:\\Users\\Nangu\\Desktop\\oneFace\\oneface\\check.py\", line 86, in check_inputs\nraise CheckError(errors)\nfuncdesc.guard.CheckError: [ValueError('Value &lt;__main__.Person object at 0x000001E9148CAD30&gt; is not in a valid range([0, 100]).')]\n</code></pre>"},{"location":"type_extension/#registration-of-interface-widgets","title":"Registration of interface widgets","text":"<p>If you want to generate the appropriate widget for your custom type, you should register it in the specific interface.</p>"},{"location":"type_extension/#register-widgets-in-qt-interface","title":"Register widgets in Qt interface","text":"<pre><code>from oneface.qt import GUI, InputItem\nfrom qtpy import QtWidgets\nclass PersonInputItem(InputItem):\ndef init_layout(self):\nself.layout = QtWidgets.QVBoxLayout()\ndef init_ui(self):\nself.name_input = QtWidgets.QLineEdit()\nself.age_input = QtWidgets.QSpinBox()\nif self.range:\nself.age_input.setMinimum(self.range[0])\nself.age_input.setMaximum(self.range[1])\nif self.default:\nself.name_input.setText(self.default.name)\nself.age_input.setValue(self.default.age)\nself.layout.addWidget(QtWidgets.QLabel(\"person:\"))\nname_row = QtWidgets.QHBoxLayout()\nname_row.addWidget(QtWidgets.QLabel(\"name:\"))\nname_row.addWidget(self.name_input)\nself.layout.addLayout(name_row)\nage_row = QtWidgets.QHBoxLayout()\nage_row.addWidget(QtWidgets.QLabel(\"age:\"))\nage_row.addWidget(self.age_input)\nself.layout.addLayout(age_row)\ndef get_value(self):\nreturn Person(self.name_input.text(), self.age_input.value())\nGUI.register_widget(Person, PersonInputItem)\n</code></pre>"},{"location":"type_extension/#register-widgets-in-dash-interface","title":"Register widgets in Dash interface","text":"<pre><code>from oneface.dash_app import App, InputItem\nfrom dash import dcc\nclass PersonInputItem(InputItem):\ndef get_input(self):\nif self.default:\ndefault_val = f\"Person('{self.default.name}', {self.default.age})\"\nelse:\ndefault_val = \"\"\nreturn dcc.Input(\nplaceholder=\"example: Person('age', 20)\",\ntype=\"text\",\nvalue=default_val,\nstyle={\n\"width\": \"100%\",\n\"height\": \"40px\",\n\"margin\": \"5px\",\n\"font-size\": \"20px\",\n}\n)\nApp.register_widget(Person, PersonInputItem)\nApp.register_type_convert(Person, lambda s: eval(s))\n</code></pre> <p>Warning</p> <p>Currently, there is no good way to composite dash components. Here, for simplicity, we use the serialized input Person. The above code is not recommended for use in production environments. see issue#1</p> <p></p>"},{"location":"type_extension/#another-example-textarea","title":"Another example: TextArea","text":"<p>Here we give another example of using TextArea to get long string input.</p> <pre><code>from oneface import one, Val\nfrom oneface.dash_app import App, InputItem\nfrom dash import dcc\nclass LongStrInputItem(InputItem):\ndef get_input(self):\nreturn dcc.Textarea(\nplaceholder='Enter a value...',\nvalue=(self.default or \"\"),\nstyle={'width': '100%'}\n)\nApp.register_widget(str, LongStrInputItem)\n@one\ndef print_doc(doc: Val(str)):\nprint(doc)\nprint_doc.dash_app()\n</code></pre> <p></p> <p>More details on the dash component definition can be found in the dash documentation.</p>"},{"location":"wrap_cli/","title":"Wrap command line","text":"<p>Another way to use oneFace is to wrap a command line program. From the perspective of implementation, it's a layer of wrapping around the oneFace API. You can use a YAML configuration file to describe the command line to be wrapped and the type, range and default value of each parameter.</p> <p>Here is an example YAML file:</p> <pre><code># example.yaml\n# The name of your app\nname: add\n# The target command to be wraped.\n# Use '{}' to mark all arguments.\ncommand: python -c \"print({a} + {b})\" # List all argument's type and range\ninputs:\na:\ntype: int\nrange: [0, 10]\nb:\ntype: int\nrange: [-10, 10]\ndefault: 0\n# Interface specific config\n# These parameters will pass to the interface\nqt_config:\n# qt related config\nrun_once: false\ndash_config:\n# Dash related config\nconsole_interval: 2000\n</code></pre> <p>You can generate this file to your working path, using:</p> <pre><code>$ python -m oneface.wrap_cli generate ./example.yaml\n</code></pre> <p>Then you can lanuch the application with:</p> <pre><code>$ python -m oneface.wrap_cli run example.yaml qt_gui  # or\n$ python -m oneface.wrap_cli run example.yaml dash_app\n</code></pre>"},{"location":"wrap_cli/#flag-insertion","title":"Flag insertion","text":"<p>Extra string can insert to the actually executed command when the parameter is a <code>bool</code> type. It's useful when the command contains some \"Flag\" parameters. For example:</p> <pre><code>name: add\ncommand: python {verbose} -c \"print({a} + {b})\" inputs:\nverbose:\ntype: bool\ndefault: False\ntrue_insert: \"-v\"  # insert \"-v\" flag when verbose is True\nfalse_insert: \"\"\na:\ntype: int\nrange: [0, 10]\nb:\ntype: int\nrange: [-10, 10]\ndefault: 0\n</code></pre>"},{"location":"wrap_cli/#configurations","title":"Configurations","text":"<p>You can modify the configuration related to the specific interface(Qt and Dash). Using the corresponding fields, for example:</p> <pre><code>qt_config:\nname: \"my qt app\"\nsize: [300, 200]\nrun_once: False\ndash_config:\nhost: 127.0.0.1\nport: 8989\nshow_console: True\nconsole_interval: 2000\ninit_run: True\n</code></pre> <p>And parameter related configrations should set to the corresponding argument fields. For example:</p> <pre><code>inputs:\na:\ntype: int\nrange: [0, 10]\ninteractive: True  # will let this argument interactive in dash app\n</code></pre>"}]}